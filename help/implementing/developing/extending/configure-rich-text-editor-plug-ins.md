---
title: ' [!DNL Adobe Experience Manager]에서 리치 텍스트 편집기 플러그인을 구성합니다.'
description: ' [!DNL Adobe Experience Manager] 리치 텍스트 편집기 플러그인을 구성하는 방법을 알아봅니다.'
contentOwner: AG
mini-toc-levels: 1
exl-id: 91619662-e865-47d1-8bec-0739f402353a
source-git-commit: 90de3cf9bf1c949667f4de109d0b517c6be22184
workflow-type: tm+mt
source-wordcount: '4301'
ht-degree: 3%

---

# 리치 텍스트 편집기 플러그인 구성 {#configure-the-rich-text-editor-plug-ins}

RTE 기능은 각각 기능 속성이 있는 일련의 플러그인을 통해 사용할 수 있습니다. 하나 이상의 RTE 기능을 활성화하거나 비활성화하도록 기능 속성을 구성할 수 있습니다. 이 문서에서는 RTE 플러그인을 구체적으로 구성하는 방법을 설명합니다.

다른 RTE 구성에 대한 자세한 내용은 [리치 텍스트 편집기 구성](/help/implementing/developing/extending/rich-text-editor.md)을 참조하십시오.

>[!NOTE]
>
>CRXDE Lite 작업 시 [!UICONTROL 모두 저장] 옵션을 사용하여 정기적으로 변경 내용을 저장하는 것이 좋습니다.

## 플러그인 활성화 및 기능 속성 구성 {#activateplugin}

플러그인을 활성화하려면 다음 단계를 수행하십시오. 일부 단계는 해당 노드가 없으므로 처음으로 플러그인을 구성할 때만 필요합니다.

기본적으로 `format`, `link`, `list`, `justify` 및 `control` 플러그인과 모든 기능이 RTE에서 활성화됩니다.

>[!NOTE]
>
>이 문서에서 중복을 방지하기 위해 각각의 `rtePlugins` 노드를 `<rtePlugins-node>` 라고 합니다.

1. CRXDE Lite을 사용하여 프로젝트의 텍스트 구성 요소를 찾습니다.
1. RTE 플러그인을 구성하기 전에 `<rtePlugins-node>` 의 상위 노드가 없으면 이를 만드십시오.

   * 구성 요소에 따라 상위 노드는 다음과 같습니다.

      * `config: .../text/cq:editConfig/cq:inplaceEditing/config`
      * 대체 구성 노드:`.../text/cq:editConfig/cq:inplaceEditing/inplaceEditingTextConfig`
      * `text: .../text/dialog/items/tab1/items/text`
   * 유형:**jcr:primaryType** `cq:Widget`
   * 두 속성 모두 다음 속성을 갖습니다.

      * **이름** `name`
      * **유형** `String`
      * **값** `./text`


1. 구성할 인터페이스에 따라 노드 `<rtePlugins-node>`이 없는 경우 노드를 만듭니다.

   * **이름** `rtePlugins`
   * **유형** `nt:unstructured`

1. 아래에서 활성화할 각 플러그인에 대해 노드를 만듭니다.

   * **유형** `nt:unstructured`
   * **** 필요한 플러그인의 플러그인 ID라는 이름을 지정합니다

플러그인을 활성화한 후 다음 지침에 따라 `features` 속성을 구성하십시오.

|  | 모든 기능 활성화 | 몇 가지 특정 기능을 활성화합니다. | 모든 기능을 비활성화합니다. |
|---|---|---|---|
| 이름 | 기능 | 기능 | 기능 |
| 유형 | 문자열 | `String` (다중 문자열)type 을 (으) `String` 로 설정하고 CRXDE Lite  `Multi` in 을 클릭합니다.) | 문자열 |
| 값 | `*` (별표) | 하나 이상의 피쳐 값으로 설정합니다. | - |

## Finderplace 플러그인 이해 {#findreplace}

`findreplace` 플러그인은 구성이 필요하지 않습니다. 그것은 즉시 작동합니다.

바꾸기 기능을 사용할 때 바꿀 바꾸기 문자열을 찾기 문자열과 동시에 입력해야 합니다. 그러나 문자열을 대체하기 전에 찾기 를 클릭하여 검색할 수 있습니다. 찾기를 클릭한 후 바꾸기 문자열을 입력하면 검색이 텍스트 시작 부분으로 재설정됩니다.

찾기를 클릭하면 찾기 및 바꾸기 대화 상자가 투명해지고 바꾸기를 클릭하면 불투명해집니다. 동작을 사용하면 작성자가 대체할 텍스트를 검토할 수 있습니다. 사용자가 모두 바꾸기를 클릭하면 대화 상자가 닫히고 교체 수가 표시됩니다.

## 붙여넣기 모드 구성 {#pastemodes}

RTE를 사용할 때 작성자가 다음 세 가지 모드 중 하나로 컨텐츠를 붙여넣을 수 있습니다.

* **브라우저 모드**:브라우저의 기본 붙여넣기 구현을 사용하여 텍스트를 붙여넣습니다. 원하지 않는 마크업을 도입할 수 있으므로 권장되지 않는 방법입니다.

* **일반 텍스트 모드**:클립보드 내용을 일반 텍스트로 붙여넣습니다. [!DNL Experience Manager] 구성 요소에 삽입하기 전에 복사한 컨텐츠에서 스타일 및 서식의 모든 요소를 제거합니다.

* **MS Word 모드**:MS Word에서 복사할 때 서식을 지정하여 표를 포함한 텍스트를 붙여넣습니다. 웹 페이지나 MS Excel과 같은 다른 소스에서 텍스트를 복사하고 붙여넣는 것은 지원되지 않으며 부분 형식만 유지합니다.

### RTE 도구 모음 {#configure-paste-options-available-on-the-rte-toolbar}에서 사용할 수 있는 붙여넣기 옵션 구성

RTE 도구 모음에서 작성자에게 이 세 가지 아이콘 중 일부, 전체 또는 하나도 제공할 수 없습니다.

* **[!UICONTROL 붙여넣기(Ctrl+V)]**:위의 세 가지 붙여넣기 모드 중 하나에 해당하도록 사전 구성할 수 있습니다.

* **[!UICONTROL 텍스트로 붙여넣기]**:일반 텍스트 모드 기능을 제공합니다.

* **[!UICONTROL Word에서 붙여넣기]**:MS Word 모드 기능을 제공합니다.

필요한 아이콘을 표시하도록 RTE를 구성하려면 다음 단계를 따르십시오.

1. 구성 요소로 이동합니다(예: `/apps/<myProject>/components/text`).
1. `rtePlugins/edit` 노드로 이동합니다. 노드가 없으면 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `edit` 노드에서 `features` 속성을 만들고 하나 이상의 기능을 추가합니다. 모든 변경 내용을 저장합니다.

### 붙여넣기(Ctrl+V) 아이콘과 바로 가기 {#configure-the-behavior-of-the-paste-ctrl-v-icon-and-shortcut}의 동작을 구성합니다

다음 단계를 사용하여 **[!UICONTROL 붙여넣기(Ctrl+V)]** 아이콘의 동작을 미리 구성할 수 있습니다. 또한 이 구성은 작성자가 컨텐츠를 붙여넣는 데 사용하는 키보드 단축키 Ctrl+V의 동작을 정의합니다.

구성에서는 다음 세 가지 유형의 사용 사례를 허용합니다.

* 브라우저의 기본 붙여넣기 구현을 사용하여 텍스트를 붙여넣습니다. 원하지 않는 마크업을 도입할 수 있으므로 권장되지 않는 방법입니다. 아래의 `browser`을 사용하여 구성했습니다.

* 클립보드 내용을 일반 텍스트로 붙여넣습니다. [!DNL Experience Manager] 구성 요소에 삽입하기 전에 복사한 컨텐츠에서 스타일 및 서식의 모든 요소를 제거합니다. 아래의 `plaintext`을 사용하여 구성했습니다.

* MS Word에서 복사할 때 서식을 지정하여 표를 포함한 텍스트를 붙여넣습니다. 웹 페이지나 MS Excel과 같은 다른 소스에서 텍스트를 복사하고 붙여넣는 것은 지원되지 않으며 부분 형식만 유지합니다. 아래의 `wordhtml`을 사용하여 구성했습니다.

1. 구성 요소에서 `<rtePlugins-node>/edit` 노드로 이동합니다. 노드가 없으면 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `edit` 노드에서 다음 세부 정보를 사용하여 속성을 만듭니다.

   * **이름** `defaultPasteMode`
   * **유형** `String`
   * **** 값은  `browser`,  `plaintext`또는 모드에서 필요한 붙여넣기 모드 중  `wordhtml` 하나입니다.

### 컨텐츠를 붙여넣을 때 허용되는 형식을 구성합니다 {#pasteformats}

[!DNL Microsoft Word] 등의 다른 프로그램에서 [!DNL Experience Manager]에 붙여넣을 때 명시적으로 몇 가지 스타일을 허용할 수 있도록 붙여넣기 as-Microsoft-Word(`paste-wordhtml`) 모드를 추가로 구성할 수 있습니다.

예를 들어 [!DNL Experience Manager]에서 붙여넣을 때 굵은 서식과 목록만 허용하면 다른 형식을 필터링할 수 있습니다. 이를 구성 가능한 붙여넣기 필터링이라고 하며 두 작업 모두에 대해 수행할 수 있습니다.

* [텍스트](#pastemodes)
* [링크](#linkstyles)

링크의 경우 자동으로 수락되는 프로토콜을 정의할 수도 있습니다.

다른 프로그램에서 [!DNL Experience Manager]에 텍스트를 붙여넣을 때 허용되는 형식을 구성하려면:

1. 구성 요소에서 노드 `<rtePlugins-node>/edit`로 이동합니다. 노드가 없으면 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `edit` 노드 아래에 노드를 만들어 HTML 붙여넣기 규칙을 유지합니다.

   * **이름** `htmlPasteRules`
   * **유형** `nt:unstructured`

1. `htmlPasteRules` 아래에 노드를 만들어 허용되는 기본 형식의 세부 정보를 보관하십시오.

   * **이름** `allowBasics`
   * **유형** `nt:unstructured`

1. 허용되는 개별 형식을 제어하려면 `allowBasics` 노드에서 다음 속성 중 하나 이상을 만드십시오.

   * **이름** `bold`
   * **이름** `italic`
   * **이름** `underline`
   * **이름** `anchor` (링크와 명명된 앵커 모두에 대해)
   * **이름** `image`

   모든 속성은 **Type** `Boolean`이므로 적절한 **값**&#x200B;에서 확인 표시를 선택하거나 제거하여 기능을 활성화하거나 비활성화할 수 있습니다.

   >[!NOTE]
   >
   >명시적으로 정의되지 않은 경우 기본값인 true가 사용되고 형식이 수락됩니다.

1. 다른 형식도 `htmlPasteRules` 노드에 적용되는 다양한 다른 속성 또는 노드를 사용하여 정의할 수 있습니다.

| 속성 | 유형 | 설명 |
|--- |--- |--- |
| `allowBlockTags` | `String` | 허용되는 블록 태그 목록을 정의합니다. 가능한 몇 가지 블록 태그에는 제목(h1, h2, h3), 단락(p), 목록(ol, ul), 표(테이블)가 포함됩니다. |
| `fallbackBlockTag` | `String` | `allowBlockTags`에 포함되지 않은 블록 태그가 있는 모든 블록에 사용되는 블록 태그를 정의합니다. 일반적으로 `p` 접미사가 필요합니다. |
| `table` | `nt:unstructured` | 표를 붙여넣을 때의 동작을 정의합니다. 이 노드에는 테이블 붙여넣기가 허용되는지 여부를 정의할 수 있는 허용(부울 유형)이 있어야 합니다. allow가 false로 설정된 경우 붙여넣기가 수행된 테이블 컨텐츠를 처리하는 방법을 정의하려면 ignoreMode(String 유형) 속성을 지정해야 합니다. ignoreMode에 대한 유효한 값은 테이블 컨텐츠를 제거하는 `remove`, 테이블 셀을 단락으로 변환하는 `paragraph` 입니다. |
| `list` | `nt:unstructured` | 목록을 붙여넣을 때의 동작을 정의합니다. 목록 붙여넣기가 허용되는지 여부를 정의하려면 `allow` 속성(부울 유형)이 있어야 합니다. `allow`이 `false`로 설정된 경우 `ignoreMode` 속성(`String` 유형)을 지정하여 붙여넣은 목록 컨텐츠를 처리하는 방법을 정의합니다. ignoreMode의 유효한 값은 목록 컨텐츠를 제거하는 `remove` 및 목록 항목을 단락으로 바꾸는 `paragraph` 입니다. |

유효한 `htmlPasteRules` 구조의 예는 다음과 같습니다.

```xml
"htmlPasteRules": {
    "allowBasics": {
        "italic": true,
        "link": true
    },
    "allowBlockTags": [
        "p", "h1", "h2", "h3"
    ],
    "list": {
        "allow": false,
        "ignoreMode": "paragraph"
    },
    "table": {
        "allow": true,
        "ignoreMode": "paragraph"
    }
}
```

1. 모든 변경 내용을 저장합니다.

## 텍스트 스타일 구성 {#textstyles}

작성자가 스타일을 적용하여 텍스트 부분을 변경할 수 있습니다. 스타일은 CSS 스타일 시트에서 미리 정의한 CSS 클래스를 기반으로 합니다. 스타일이 지정된 컨텐츠는 CSS 클래스를 참조할 때 `class` 속성을 사용하여 `span` 태그로 묶입니다. 예:

`<span class=monospaced>Monospaced Text Here</span>`

스타일 플러그인이 처음 활성화되면 기본 스타일을 사용할 수 없습니다. 팝업 목록이 비어 있습니다. 작성자에게 스타일을 제공하려면 다음을 수행하십시오.

* 스타일 드롭다운 선택기를 활성화합니다.
* 스타일 시트의 위치를 하나 이상 지정합니다.
* 스타일 팝업 목록에서 선택할 수 있는 개별 스타일을 지정합니다.

나중에 다시 구성하는 경우 스타일을 더 추가하려면 지침만 따라 새 스타일 시트를 참조하고 추가 스타일을 지정합니다.

>[!NOTE]
>
>[표 또는 표 셀](configure-rich-text-editor-plug-ins.md#tablestyles)에 대해서도 스타일을 정의할 수 있습니다. 이러한 구성에는 별도의 절차가 필요합니다.

### 스타일 드롭다운 선택기 목록 활성화 {#styleselectorlist}

이 작업은 스타일 플러그인을 활성화하여 수행됩니다.

1. 구성 요소에서 노드 `<rtePlugins-node>/styles`로 이동합니다. 노드가 없으면 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `styles` 노드에서 `features` 속성을 만듭니다.

   * **이름** `features`
   * **유형** `String`
   * **값** `*` (별표)

1. 모든 변경 내용을 저장합니다.

>[!NOTE]
>
>스타일 플러그인이 활성화되면 스타일 드롭다운 목록이 편집 대화 상자에 표시됩니다. 하지만 스타일이 구성되지 않아 목록이 비어 있습니다.

### 스타일시트 위치를 지정합니다 {#locationofstylesheet}

그런 다음 참조할 스타일 시트의 위치를 지정합니다.

1. 텍스트 구성 요소의 루트 노드(예: `/apps/<myProject>/components/text`)로 이동합니다.
1. `<rtePlugins-node>` 의 상위 노드에 속성 `externalStyleSheets`을 추가합니다.

   * **이름** `externalStyleSheets`
   * **유형** `String[]` (다중 문자열;다중  **** CRXDE 클릭)
   * **값**  포함할 모든 스타일 시트의 경로 및 파일 이름입니다. 저장소 경로를 사용합니다.

   >[!NOTE]
   >
   >나중에 언제든지 추가 스타일 시트에 대한 참조를 추가할 수 있습니다.

1. 모든 변경 내용을 저장합니다.

대화 상자에서 RTE 사용(클래식 UI) 리치 텍스트 편집에 최적화된 스타일 시트를 지정할 수 있습니다. 기술 제한 사항으로 인해 CSS 컨텍스트는 편집기에서 손실되므로 이 컨텍스트를 에뮬레이션하여 WYSIWYG 경험을 향상시킬 수 있습니다.

리치 텍스트 편집기에서는 보고 편집할 다른 스타일을 제공하는 `CQrte` ID가 있는 컨테이너 DOM 요소를 사용합니다.

```css
#CQ td {
// defines the style for viewing
 }
```

```css
#CQrte td {
 // defines the style for editing
 }
```

### 팝업 목록에서 사용 가능한 스타일을 지정합니다 {#stylesindropdown}

1. 구성 요소 정의에서 [스타일 드롭다운 선택기](#styleselectorlist)에서 만든 대로 노드 `<rtePlugins-node>/styles`로 이동합니다.
1. 노드 `styles` 아래에 노드(`styles`라고도 함)를 만들어 사용 가능한 목록을 유지합니다.

   * **이름** `styles`
   * **유형** `cq:WidgetCollection`

1. `styles` 노드 아래에 노드를 만들어 개별 스타일을 나타냅니다.

   * **이름** 을 지정할 수 있지만 스타일에 적합해야 합니다
   * **유형** `nt:unstructured`

1. CSS 클래스를 참조할 수 있도록 이 노드에 속성 `cssName`을 추가합니다.

   * **이름** `cssName`
   * **유형** `String`
   * **** 값이전 &#39;.&#39; 없이 CSS 클래스의 이름입니다.;예를 들어 `.cssClass` 대신 `cssClass`)이 사용됩니다.

1. 속성 `text`을 동일한 노드에 추가합니다.선택 상자에 표시되는 텍스트를 정의합니다.

   * **이름** `text`
   * **유형** `String`
   * **** 값스타일에 대한 설명;스타일 드롭다운 선택 상자에 나타납니다.

1. 변경 사항을 저장합니다.

   필요한 각 스타일에 대해 위의 단계를 반복합니다.

### 일본어 단어 분리를 최적화하기 위해 RTE 구성 {#jpwordwrap}

[!DNL Experience Manager]을 사용하여 일본어 컨텐츠를 작성하는 작성자는 중단이 필요하지 않은 줄 바꿈을 방지하기 위해 문자에 스타일을 적용할 수 있습니다. 이렇게 하면 작성자가 원하는 위치에서 문장을 벗어나게 할 수 있습니다. 이 기능의 스타일은 CSS 스타일 시트에 미리 정의된 CSS 클래스를 기반으로 합니다.

작성자가 일본어 텍스트에 적용할 수 있는 스타일을 만들려면 다음 단계를 수행합니다.

1. 스타일 노드 아래에 노드를 만듭니다. [스타일](#stylesindropdown)을 지정하십시오.
   * 이름: `jpn-word-wrap`
   * 유형: `nt:unstructure`

1. CSS 클래스를 참조할 노드에 속성 `cssName`을 추가합니다. 이 클래스 이름은 일본어 자동 줄바꿈 기능에 대해 예약된 이름입니다.
   * 이름: `cssName`
   * 유형: `String`
   * 값:`jpn-word-wrap`(이전 `.` 없음)

1. 속성 텍스트를 동일한 노드에 추가합니다. 값은 작성자가 스타일을 선택할 때 표시되는 스타일의 이름입니다.
   * 이름:`text`
*유형: 
`String`
   * 값: `Japanese word-wrap`

1. 스타일 시트를 만들고 해당 경로를 지정합니다. [스타일시트 위치 지정](#locationofstylesheet)을 참조하십시오. 스타일시트에 다음 내용을 추가합니다. 원하는 대로 배경색을 변경합니다.

   ```css
   .text span.jpn-word-wrap {
       display:inline-block;
   }
   .is-edited span.jpn-word-wrap {
       background-color: #ffddff;
   }
   ```

   ![작성자가 일본어 자동 줄바꿈 기능을 사용할 수 있도록 하는 스타일 시트](assets/rte_jpwordwrap_stylesheet.jpg)

## 단락 형식 구성 {#paraformats}

RTE에서 작성된 모든 텍스트는 블록 태그 내에 배치되며, 기본값은 `<p>`입니다. `paraformat` 플러그인을 활성화하면 드롭다운 선택 목록을 사용하여 단락에 지정할 수 있는 추가 블록 태그를 지정할 수 있습니다. 단락 형식은 올바른 블록 태그를 지정하여 단락 유형을 결정합니다. 작성자는 형식 선택기를 사용하여 선택하여 할당할 수 있습니다. 예제 블록 태그에는 표준 단락 &lt;p> 및 제목 &lt;h1>, &lt;h2> 등이 포함됩니다.

>[!CAUTION]
>
>이 플러그인은 목록 또는 표와 같은 복잡한 구조의 컨텐츠에는 적합하지 않습니다.

>[!NOTE]
>
>예를 들어 `<hr>` 태그와 같은 블록 태그를 단락에 할당할 수 없는 경우, `paraformat` 플러그인에 유효한 사용 사례가 아닙니다.

단락 형식 플러그인이 처음 활성화되면 기본 단락 형식 을 사용할 수 없습니다. 팝업 목록이 비어 있습니다. 작성자에게 단락 형식을 제공하려면 다음을 수행하십시오.

* [!UICONTROL 형식] 팝업 선택기 목록을 활성화합니다.
* 팝업 메뉴에서 단락 형식으로 선택할 수 있는 블록 태그를 지정합니다.

나중에 다시 구성하는 경우, 형식을 더 추가하려면 지침의 관련 부분만 따르십시오.

### 형식 드롭다운 선택기를 활성화합니다 {#formatselectorlist}

`paraformat` 플러그인을 활성화하려면 다음 단계를 수행하십시오.

1. 구성 요소에서 노드 `<rtePlugins-node>/paraformat`로 이동합니다. 노드가 없으면 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `paraformat` 노드에서 `features` 속성을 만듭니다.

   * **이름** `features`
   * **유형** `String`
   * **값** `*` (별표)

>[!NOTE]
>
>플러그인이 추가로 구성되지 않은 경우 사용할 수 있는 기본 형식은 단락 ( `<p>`), 제목 1 ( `<h1>`), 제목 2 ( `<h2>`), 제목 3 ( `<h3>`)입니다.

>[!CAUTION]
>
>RTE의 단락 형식을 구성할 때는 단락 태그 &lt;p>를 서식 옵션으로 제거하지 마십시오. `<p>` 태그가 제거되면 컨텐츠 작성자는 추가 형식이 구성되어 있어도 [!UICONTROL 단락 형식] 옵션을 선택할 수 없습니다.

### 사용 가능한 단락 형식 지정 {#paraformatsindropdown}

단락 포맷은 다음 방법으로 선택할 수 있습니다.

1. 구성 요소 정의에서 [형식 드롭다운 선택기](#styleselectorlist)에서 만든 대로 노드 `<rtePlugins-node>/paraformat`로 이동합니다.
1. `paraformat` 노드 아래에 노드를 만들어 형식 목록을 보관합니다.

   * **이름** `formats`
   * **유형** `cq:WidgetCollection`

1. `formats` 노드 아래에 노드를 만들면 개별 형식에 대한 세부 정보가 포함됩니다.

   * **이름** 을 지정할 수 있지만 형식에 적합해야 합니다(예: myparagraph, myheading1).
   * **유형** `nt:unstructured`

1. 이 노드에 속성을 추가하여 사용되는 블록 태그를 정의합니다.

   * **이름** `tag`
   * **유형** `String`
   * **** 값 형식의 블록 태그입니다.예:p, h1, h2 등

      구분 꺾쇠 괄호는 입력할 필요가 없습니다.

1. 동일한 노드에 다른 속성을 추가하려면 설명 텍스트가 드롭다운 목록에 나타나도록 합니다.

   * **이름** `description`
   * **유형** `String`
   * **** 값이 형식을 설명하는 텍스트입니다.예를 들어, 단락, 머리글 1, 머리글 2 등이 있습니다. 이 텍스트는 형식 선택 목록에 표시됩니다.

1. 변경 사항을 저장합니다.

   필요한 각 형식에 대한 단계를 반복합니다.

>[!CAUTION]
사용자 지정 형식을 정의하는 경우 기본 형식(`<p>`, `<h1>`, `<h2>` 및 `<h3>`)이 제거됩니다. 기본 형식이므로 `<p>` 형식을 다시 만듭니다.

## 특수 문자 구성 {#spchar}

표준 [!DNL Experience Manager] 설치에서 특수 문자(`specialchars`)에 대해 `misctools` 플러그인이 활성화되면 즉시 사용할 수 있습니다.예를 들어, 저작권 및 상표 기호

RTE를 구성하여 선택한 문자를 사용할 수 있도록 할 수 있습니다.또는 전체 시퀀스를 정의하여

>[!CAUTION]
특수 문자를 추가하면 기본 선택 내용이 무시됩니다. 필요한 경우 선택 항목에서 이러한 문자를 재정의합니다.

### 단일 문자 정의 {#definesinglechar}

1. 구성 요소에서 노드 `<rtePlugins-node>/misctools`로 이동합니다. 노드가 없으면 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `misctools` 노드에서 `features` 속성을 만듭니다.

   * **이름** `features`
   * **유형** `String[]`
   * **값** `specialchars`

          (또는 이 플러그인에 대한 모든 기능을 적용하는 경우 `String / *`)

1. `misctools`에서 특수 문자 구성을 보유할 노드를 만듭니다.

   * **이름** `specialCharsConfig`
   * **유형** `nt:unstructured`

1. `specialCharsConfig` 아래에 문자 목록을 저장할 다른 노드를 만듭니다.

   * **이름** `chars`
   * **유형** `nt:unstructured`

1. `chars` 아래에 개별 문자 정의를 보유할 노드를 추가합니다.

   * **** 이름이름을 지정할 수 있지만 문자를 반영해야 합니다.예를 들면 절반입니다.
   * **유형** `nt:unstructured`

1. 이 노드에 다음 속성을 추가합니다.

   * **이름** `entity`
   * **유형** `String`
   * **** 값은 필요한 문자의 HTML 표현입니다.예를 들어, 분수 1 `&189;` 분의 경우.

1. 변경 사항을 저장합니다.

CRXDE에서 속성이 저장되면 표현된 문자가 표시됩니다. 반쪽의 예제 아래를 참조하십시오. 위 단계를 반복하여 작성자가 더 특수 문자를 사용할 수 있습니다.

![CRXDE에서 RTE 도구 모음에서 사용할 수 있는 단일 문자](assets/chlimage_1-106.png "를 추가합니다.CRXDE에서 RTE 도구 모음에서 사용할 수 있도록 단일 문자를 추가합니다")

### 문자 범위 정의 {#definerangechar}

1. [단일 문자](#definesinglechar)에서 1~3단계를 사용합니다.
1. `chars` 아래에 노드를 추가하여 문자 범위의 정의를 유지하십시오.

   * **** 이름 이름은 지정할 수 있지만 문자 범위를 반영해야 합니다.예를 들면 연필입니다.
   * **유형** `nt:unstructured`

1. 이 노드(특수 문자 범위에 따라 이름이 지정됨) 아래에 다음 두 속성을 추가합니다.

   * **이름** `rangeStart`

      **유형** `Long`
      **** 값 [](https://unicode.org/) 에서 첫 번째 문자의 유니코데표현(십진수)입니다

   * **이름** `rangeEnd`

      **유형** `Long`
      **** 값 [](https://unicode.org/) 에 있는 마지막 문자의 유니코드 표현(십진수)입니다

1. 변경 사항을 저장합니다.

   예를 들어, 998 - 10000에서 범위를 정의하면 다음 문자가 제공됩니다.

   ![CRXDE에서 RTE에서 사용할 수 있는 문자 범위를 정의합니다](assets/chlimage_1-107.png)

   *그림:CRXDE에서 RTE에서 사용할 수 있는 문자 범위를 정의합니다*

   ![RTE에서 사용할 수 있는 특수 문자는 팝업 ](assets/rtepencil.png "창에서 작성자에게 표시되고, RTE에서는 사용할 수 있는 특수 문자가 팝업 창에 작성자에게 표시됩니다")

## 표 스타일 구성 {#tablestyles}

스타일은 일반적으로 텍스트에 적용되지만 별도의 스타일 세트를 테이블이나 몇 개의 표 셀에도 적용할 수 있습니다. 이러한 스타일은 셀 속성 또는 표 속성 대화 상자의 스타일 선택기 상자에서 작성자가 사용할 수 있습니다. 스타일은 표준 표 구성 요소가 아니라 텍스트 구성 요소(또는 파생) 내에서 표를 편집할 때 사용할 수 있습니다.

>[!NOTE]
클래식 UI의 표 및 셀에 대해서만 스타일을 정의할 수 있습니다.

>[!NOTE]
RTE 구성 요소에서 또는 에서 표를 복사하고 붙여넣는 것은 브라우저에 따라 다릅니다. 모든 브라우저에 대해 기본적으로 지원되지 않습니다. 테이블 구조 및 브라우저에 따라 다양한 결과를 얻을 수 있습니다. 예를 들어, 클래식 UI 및 Touch UI에서 Mozilla Firefox의 RTE 구성 요소에 표를 복사하여 붙여넣으면 표의 레이아웃이 유지되지 않습니다.

1. 구성 요소 내에서 `<rtePlugins-node>/table` 노드로 이동합니다. 노드가 없으면 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `table` 노드에서 `features` 속성을 만듭니다.

   * **이름** `features`
   * **유형** `String`
   * **값** `*`

   >[!NOTE]
   모든 테이블 기능을 활성화하지 않으려면 `features` 속성을 다음과 같이 만들 수 있습니다.
   * **유형** `String[]`

   * **필요에 따라 다음 값** 1 또는 둘 다:
      * `table` 표 속성을 편집할 수 있도록 허용스타일을 포함합니다.
      * `cellprops` 스타일을 포함하여 셀 속성을 편집할 수 있도록 허용합니다.


1. CSS 스타일 시트의 위치를 정의하여 이를 참조합니다. [텍스트](#textstyles)에 대한 [스타일을 정의할 때와 동일하게 스타일 시트](#locationofstylesheet)의 위치 지정을 참조하십시오. 다른 스타일을 정의한 경우 위치를 정의할 수 있습니다.
1. `table` 노드 아래에 필요에 따라 다음 노드를 만듭니다.

   * 전체 테이블의 스타일을 정의하려면( **[!UICONTROL 표 속성]**&#x200B;에서 사용 가능):

      * **이름** `tableStyles`
      * **유형** `cq:WidgetCollection`
   * 개별 셀의 스타일을 정의하려면(**[!UICONTROL 셀 속성]**&#x200B;에서 사용 가능),

      * **이름** `cellStyles`
      * **유형** `cq:WidgetCollection`


1. 노드를 만들기(`tableStyles` 또는 `cellStyles` 노드 아래에 적절하게).

   * **** 이름이름을 지정할 수 있지만 스타일을 반영해야 합니다.
   * **유형** `nt:unstructured`

1. 이 노드에서 속성을 만듭니다.

   * 참조되는 CSS 스타일을 정의하려면

      * **이름** `cssName`
      * **유형** `String`
      * **** 값은 CSS 클래스의 이름(예:  `.`대신  `cssClass`   `.cssClass`를 선행 없이)입니다.
   * 팝업 선택기에 표시할 설명 텍스트를 정의하려면

      * **이름** `text`
      * **유형** `String`
      * **** 값 선택 목록에 표시할 텍스트입니다


1. 모든 변경 내용을 저장합니다.

필요한 각 스타일에 대해 위의 단계를 반복합니다.

### 접근성을 위해 테이블에서 숨겨진 헤더 구성 {#hiddenheader}

열 헤더에서 헤더의 목적이 다른 열과 열의 시각적 관계에 의해 암묵된다고 가정할 때, 시각적 텍스트 없이 데이터 표를 만들 수 있습니다. 이 경우, 다양한 요구 사항이 있는 독자가 열의 목적을 이해하는 데 도움이 되도록 머리글 셀의 셀 내에 숨겨진 내부 텍스트를 제공하는 것이 필요합니다.

이러한 시나리오에서 액세스 가능성을 향상시키기 위해 RTE는 숨겨진 헤더 셀을 지원합니다. 또한 테이블의 숨겨진 헤더와 관련된 구성 설정을 제공합니다. 이러한 설정을 사용하면 편집 및 미리 보기 모드에서 숨겨진 헤더에 CSS 스타일을 적용할 수 있습니다. 작성자가 편집 모드에서 숨겨진 헤더를 식별하는 데 도움이 되도록 코드에 다음 매개 변수를 포함하십시오.

* `hiddenHeaderEditingCSS`:RTE를 편집할 때 숨겨진 헤더 셀에 적용되는 CSS 클래스의 이름을 지정합니다.
* `hiddenHeaderEditingStyle`:RTE를 편집할 때 숨겨진 헤더 셀에 적용되는 스타일 문자열을 지정합니다.

코드에서 CSS와 스타일 문자열을 모두 지정하는 경우 CSS 클래스가 스타일 문자열보다 우선하며 스타일 문자열의 구성 변경 사항을 덮어쓸 수 있습니다.

작성자가 미리 보기 모드에서 숨겨진 헤더에 CSS를 적용할 수 있도록 코드에 다음 매개 변수를 포함할 수 있습니다.

* `hiddenHeaderClassName`:미리 보기 모드에서 숨김 헤더 셀에 적용되는 CSS 클래스의 이름을 지정합니다.
* `hiddenHeaderStyle`:미리 보기 모드에서 숨김 헤더 셀에 적용되는 스타일 문자열을 지정합니다.

코드에서 CSS와 스타일 문자열을 모두 지정하는 경우 CSS 클래스가 스타일 문자열보다 우선하며 스타일 문자열의 구성 변경 사항을 덮어쓸 수 있습니다.

## 맞춤법 검사기의 사전 추가 {#adddict}

맞춤법 검사 플러그인이 활성화되면 RTE에서는 각 적절한 언어에 대해 사전을 사용합니다. 그런 다음 하위 트리의 언어 속성을 사용하거나 URL에서 언어를 추출하여 웹 사이트의 언어에 따라 선택됩니다.예. `/en/` 분기는 영어로 확인되고, `/de/` 분기는 독일어로 표시됩니다.

>[!NOTE]
&quot;맞춤법 검사에 실패했습니다.&quot;라는 메시지가 표시됩니다. 설치되어 있지 않은 언어를 확인하는 경우 이 표시됩니다.

표준 Experience Manager 설치에는 다음에 대한 사전이 포함되어 있습니다.

* 미국 영어(en_us)
* 영어(en_gb)

>[!NOTE]
표준 사전은 적절한 ReadMe 파일과 함께 `/libs/cq/spellchecker/dictionaries`에 있습니다. 파일을 수정하지 마십시오.

필요한 경우 사전을 더 추가하려면 다음 단계를 따르십시오.

1. 페이지 [https://extensions.openoffice.org/](https://extensions.openoffice.org/)로 이동합니다.
1. 필요한 언어를 선택하고 맞춤법 정의가 있는 ZIP 파일을 다운로드합니다. 파일 시스템에서 아카이브 컨텐츠를 추출합니다.

   >[!CAUTION]
   OpenOffice.org v2.0.1 이하 버전의 `MySpell` 형식의 사전만 지원됩니다. 이제 사전이 파일을 보관하므로 다운로드한 후 아카이브를 확인하는 것이 좋습니다.

1. .aff 및 .dic 파일을 찾습니다. 파일 이름을 소문자로 유지합니다. 예: `de_de.aff` 및 `de_de.dic`
1. 저장소에서 .aff 및 .dic 파일을 `/apps/cq/spellchecker/dictionaries`에 로드합니다.

>[!NOTE]
RTE 맞춤법 검사기는 온디맨드로 사용할 수 있습니다. 텍스트 입력을 시작할 때 자동으로 실행되지 않습니다.
맞춤법 검사기를 실행하려면 도구 모음에서 맞춤법 검사 단추를 탭/클릭합니다. RTE는 단어의 맞춤법을 검사하고 맞춤법이 잘못된 단어를 강조 표시합니다.
맞춤법 검사기에서 제안하는 변경 내용을 통합하는 경우 텍스트 변경 상태와 철자가 잘못된 단어가 더 이상 강조 표시되지 않습니다. 맞춤법 검사기를 실행하려면 맞춤법 검사 단추를 다시 탭/클릭합니다.

## 실행 취소 및 다시 실행 작업에 대한 기록 크기 구성 {#undohistory}

RTE를 통해 작성자는 몇 개의 마지막 편집 내용을 실행 취소하거나 재실행할 수 있습니다. 기본적으로 50개의 편집 내용이 기록에 저장됩니다. 필요에 따라 이 값을 구성할 수 있습니다.

1. 구성 요소 내에서 `<rtePlugins-node>/undo` 노드로 이동합니다. 이러한 노드가 없는 경우 해당 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `undo` 노드에서 속성을 만듭니다.

   * **이름** `maxUndoSteps`
   * **유형** `Long`
   * **** 값 기록에 저장하려는 실행 취소 단계 수입니다. 기본값은 50입니다. `0` 을 사용하여 실행 취소/다시 실행을 완전히 비활성화합니다.

1. 변경 사항을 저장합니다.

## 탭 크기 구성 {#tabsize}

텍스트 내에서 탭 문자를 누르면 사전 정의된 공백 수가 삽입됩니다.기본적으로 3개의 줄바꿈 없는 공백과 1개의 공백이 있습니다.

탭 크기를 정의하려면

1. 구성 요소에서 노드 `<rtePlugins-node>/keys`로 이동합니다. 노드가 없으면 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `keys` 노드에서 속성을 만듭니다.

   * **이름** `tabSize`
   * **유형** `String`
   * **** 값 테이블에 사용할 공백 문자 수입니다.

1. 변경 사항을 저장합니다.

## 들여쓰기 여백 설정 {#indentmargin}

들여쓰기를 활성화하면(기본값) 들여쓰기 크기를 정의할 수 있습니다.

>[!NOTE]
이 들여쓰기 크기는 텍스트 단락(블록)에만 적용됩니다.실제 목록의 들여쓰기에는 영향을 주지 않습니다.

1. 구성 요소 내에서 `<rtePlugins-node>/lists` 노드로 이동합니다. 이러한 노드가 없는 경우 해당 노드를 만듭니다. 자세한 내용은 [플러그인 활성화](#activateplugin)를 참조하십시오.
1. `lists` 노드에서 `identSize` 매개 변수를 만듭니다.

   * **이름**: `identSize`
   * **유형**: `Long`
   * **값**:들여쓰기 여백에 필요한 픽셀 수

## 편집 가능한 공간의 높이 구성 {#editablespace}

구성 요소 대화 상자에 표시된 편집 가능한 공간의 높이를 정의할 수 있습니다. 구성은 대화 상자에서 RTE를 사용할 때만 적용할 수 있습니다. 구성은 대화 상자 창의 높이를 변경하지 않습니다.

1. `../items/text` 노드의 구성 요소에 대한 대화 상자 정의에서 속성을 만듭니다.

   * **이름** `height`
   * **유형** `Long`
   * **** 편집 캔버스의 높이(픽셀 단위)입니다.

1. 변경 사항을 저장합니다.

## 링크에 대한 스타일 및 프로토콜 구성 {#linkstyles}

[!DNL Experience Manager]에서 링크를 추가할 때 사용할 CSS 스타일 및 자동으로 적용할 프로토콜을 정의할 수 있습니다. 다른 프로그램에서 [!DNL Experience Manager]에 링크를 추가하는 방법을 구성하려면 HTML 규칙을 정의합니다.

1. CRXDE Lite을 사용하여 프로젝트의 텍스트 구성 요소를 찾습니다.
1. `<rtePlugins-node>` 과 동일한 수준의 노드를 만듭니다. 즉, `<rtePlugins-node>` 의 상위 노드 아래에 노드를 만듭니다.

   * **이름** `htmlRules`
   * **유형** `nt:unstructured`

   >[!NOTE]
   `../items/text` 노드에는 다음 속성이 있습니다.
   * **이름** `xtype`
   * **유형** `String`
   * **값** `richtext`

   `../items/text` 노드의 위치는 대화 상자의 구조에 따라 다를 수 있습니다. 두 가지 예제는 `/apps/myProject>/components/text/dialog/items/text` 및 `/apps/<myProject>/components/text/dialog/items/panel/items/text` 입니다.

1. `htmlRules` 아래에서 노드를 만듭니다.

   * **이름** `links`
   * **유형** `nt:unstructured`

1. `links` 노드 아래에 필요에 따라 속성을 정의합니다.

   * 내부 링크에 대한 CSS 스타일:

      * **이름** `cssInternal`
      * **유형** `String`
      * **** 값은 CSS 클래스의 이름입니다(이전 &#39;.&#39; 없음).;예를 들어 `.cssClass` 대신 `cssClass`)이 사용됩니다.
   * 외부 링크에 대한 CSS 스타일

      * **이름** `cssExternal`
      * **유형** `String`
      * **** 값은 CSS 클래스의 이름입니다(이전 &#39;.&#39; 없음).;예를 들어 `.cssClass` 대신 `cssClass`)이 사용됩니다.
   * `https://`, `https://`, `file://`, `mailto:` 등을 포함하는 유효한 **[!UICONTROL 프로토콜 배열,]**

      * **이름** `protocols`
      * **유형** `String[]`
      * **값** 하나 이상의 프로토콜
   * **defaultProtocol** ( **String** 유형의 속성):사용자가 명시적으로 지정하지 않은 경우 사용할 프로토콜입니다.

      * **이름** `defaultProtocol`
      * **유형** `String`
      * **값**&#x200B;하나 이상의 기본 프로토콜
   * 링크의 대상 속성을 처리하는 방법에 대한 정의입니다. 노드 만들기:

      * **이름** `targetConfig`
      * **유형** `nt:unstructured`

      노드 `targetConfig`에서:필수 속성을 정의합니다.

      * 대상 모드를 지정합니다.

         * **이름** `mode`
         * **유형** `String`)
         * **값** :

            * `auto`:자동 타겟 선택

               (외부 링크의 `targetExternal` 속성 또는 내부 링크의 `targetInternal`에 의해 지정됨)

            * `manual`:이 컨텍스트에서는 적용할 수 없습니다.
            * `blank`:이 컨텍스트에서는 적용할 수 없습니다.
      * 내부 링크의 대상:

         * **이름** `targetInternal`
         * **유형** `String`
         * **** 내부 링크에 대한 타겟의 값(모드가  `auto`인 경우에만 사용)
      * 외부 링크의 대상:

         * **이름** `targetExternal`
         * **유형** `String`
         * **** 외부 링크의 대상 값(모드가  `auto`인 경우에만 사용됨).








1. 모든 변경 내용을 저장합니다.
