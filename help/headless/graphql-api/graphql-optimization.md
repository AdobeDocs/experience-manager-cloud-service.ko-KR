---
title: GraphQL 쿼리 최적화
description: 헤드리스 컨텐츠 전달을 위해 Adobe Experience Manager as a Cloud Service에서 컨텐츠 조각을 필터링, 페이징 및 정렬할 때 GraphQL 쿼리를 최적화하는 방법을 알아봅니다.
source-git-commit: 0fe0bd301fb09cdc631878926f2e40df51a2cc23
workflow-type: tm+mt
source-wordcount: '1192'
ht-degree: 0%

---


# GraphQL 쿼리 최적화 {#optimizing-graphql-queries}

>[!NOTE]
>
>이러한 최적화 권장 사항을 적용하기 전에 다음 사항을 고려하십시오 [GraphQL 필터링에서 페이징 및 정렬을 위한 컨텐츠 조각 업데이트](/help/headless/graphql-api/graphql-optimized-filtering-content-update.md) 최상의 성능.

동일한 모델을 공유하는 컨텐츠 조각이 많은 AEM 인스턴스에서 GraphQL 목록 쿼리는 비용이 많이 들 수 있습니다(리소스 측면에서).

왜냐하면 *모두* GraphQL 쿼리 내에서 사용되는 모델을 공유하는 조각을 메모리에 로드해야 합니다. 시간과 메모리가 모두 소모됩니다. (최종) 결과 세트의 항목 수를 줄일 수 있는 필터링은 만 적용할 수 있습니다 **after** 전체 결과 세트를 메모리에 로드하는 중입니다.

이렇게 하면 작은 결과 세트(가능한)라도 성능이 저하될 수 있습니다. 하지만 실제로는 필터링을 적용하기 전에 내부적으로 처리해야 하므로 속도가 느려지는 것은 초기 결과 세트의 크기에 의해 발생합니다.

성능 및 메모리 문제를 줄이려면 이 초기 결과 세트를 가능한 작게 유지해야 합니다.

AEM은 GraphQL 쿼리를 최적화하는 두 가지 방법을 제공합니다.

* [하이브리드 필터링](#hybrid-filtering)
* [페이징](#paging) (또는 페이지 매김)

   * [정렬](#sorting) 은 최적화와 직접 관련이 없지만 페이징과 관련되어 있습니다

각 접근 방식에는 고유한 사용 사례 및 제한 사항이 있습니다. 이 문서에서는 하이브리드 필터링 및 페이징에 대한 정보를 제공합니다 [모범 사례](#best-practices) GraphQL 쿼리를 최적화하려면 다음을 수행하십시오.

## 하이브리드 필터링 {#hybrid-filtering}

하이브리드 필터링은 JCR 필터링과 AEM 필터링을 결합합니다.

AEM 필터링을 위해 결과 세트를 메모리에 로드하기 전에 쿼리 제약 조건의 형태로 JCR 필터를 적용합니다. JCR 필터는 이 작업 전에 불필요한 결과를 제거하므로 메모리에 로드되는 결과 세트를 줄이기 위한 것입니다.

>[!NOTE]
>
>기술적인 이유로(예: 유연성, 조각 중첩) AEM에서는 전체 필터링을 JCR에 위임할 수 없습니다.

이 기법은 GraphQL 필터가 제공하는 유연성을 유지하면서 가능한 한 많은 필터링을 JCR에 위임합니다.

## 페이징 {#paging}

AEM의 GraphQL에서는 두 가지 유형의 페이지 매김을 지원합니다.

* [제한/오프셋 기반 페이지 매김](/help/headless/graphql-api/content-fragments.md#list-offset-limit)
목록 쿼리에 사용됩니다. 다음으로 끝남 
`List`; 예, `articleList`.
이를 사용하려면 반환할 첫 번째 항목( `offset`)과 반환할 항목 수(즉, `limit`, 또는 페이지 크기 ).

* [커서 기반 페이지 매김](/help/headless/graphql-api/content-fragments.md#paginated-first-after) (으)로 표시됨 `first`및 `after`) 각 항목에 대한 고유 ID를 제공합니다. 커서라고도 합니다.
쿼리에서 이전 페이지의 마지막 항목에 대한 커서를 지정하고 페이지 크기(반환할 최대 항목 수)를 지정합니다.

   커서 기반 페이지 매김이 목록 기반 쿼리의 데이터 구조에 맞지 않으므로 AEM에서 을 도입했습니다 `Paginated` 쿼리 유형; 예 `articlePaginated`. 사용되는 데이터 구조 및 매개 변수는 [GraphQL 커서 연결사양](https://relay.dev/graphql/connections.htm).

   >[!NOTE]
   >
   >AEM은 현재 포워드 페이징(사용 `after`/`first` 매개 변수 참조).
   >
   >후방 페이징(사용 `before`/`last` 매개 변수)는 지원되지 않습니다.

## 정렬 {#sorting}

모든 정렬 기준이 최상위 조각과 관련된 경우에만 정렬이 효율적입니다.

정렬 순서에 중첩된 조각에 있는 필드가 하나 이상 포함되어 있는 경우 최상위 모델을 공유하는 모든 조각이 메모리에 로드되어야 합니다. 이로 인해 성능에 부정적인 영향이 발생합니다.

>[!NOTE]
>
>최상위 필드의 정렬도 성능에 (비록 작지만) 영향을 줍니다.

## 모범 사례 {#best-practices}

모든 최적화의 주요 목표는 초기 결과 세트를 줄이는 것입니다. 여기에 나열된 우수 사례를 통해 방법을 사용할 수 있습니다. 결합할 수 있습니다(및 필수).

### 최상위 속성만 필터링 {#filter-top-level-properties-only}

현재 JCR 수준에서 필터링은 최상위 조각에만 작동합니다.

필터가 중첩된 조각의 필드를 해결하는 경우, AEM은 기본 모델을 공유하는 모든 조각을 로드(메모리에 로드)하는 것으로 폴백해야 합니다.

최상위 레벨 조각의 필드와 중첩된 조각의 필드에 있는 필터 표현식을 와 결합하여 이러한 GraphQL 쿼리를 최적화할 수 있습니다 [AND 연산자](#logical-operations-in-filter-expressions).

### 컨텐츠 구조 사용 {#use-content-structure}

AEM에서는 일반적으로 저장소 구조를 사용하여 처리할 컨텐츠 범위를 좁히는 것이 좋습니다.

이 접근 방식은 GraphQL 쿼리에도 적용되어야 합니다.

이 작업은 `_path` 최상위 레벨 조각의 필드:

```graphql
{
  someList(filter: {
    _path: {
      _expressions: [ 
        {
          value: "/content/dam/some/sub/path/",
          _operator: STARTS_WITH
        }
      ]
    }
  }) {
    items {
      # ...
    }
  }
}
```

>[!NOTE]
>
>후행 `/` on `value` 최상의 성능을 얻으려면 가 필요합니다.

### 페이징 사용 {#use-paging}

페이징을 사용하여 초기 결과 집합을 줄일 수도 있습니다. 특히 요청에서 필터링과 정렬을 사용하지 않는 경우입니다.

중첩된 조각을 필터링하거나 정렬하는 경우, AEM에서 더 많은 양의 조각을 메모리에 로드해야 할 수 있으므로 페이지 매김된 쿼리는 느려질 수 있습니다. 따라서 필터링과 페이징을 결합하는 경우 필터링을 위한 규칙을 고려합니다(위에서 설명한 대로).

페이징의 경우 페이지 매김된 결과는 항상 명시적 또는 암시적 방식으로 정렬되므로 정렬도 마찬가지로 중요합니다.

처음 몇 개의 페이지만 검색하는 데 주로 관심이 있는 경우, `...List` 또는 `...Paginated` 쿼리 그러나 응용 프로그램에서 한 페이지 또는 두 페이지 이상의 읽기에 관심이 있는 경우 `...Paginated` 나중에 페이지를 사용할 때 보다 잘 수행되므로 쿼리를 클릭합니다.

### 필터 표현식의 논리 작업 {#logical-operations-in-filter-expressions}

중첩된 조각에서 필터링하는 경우, 를 사용하여 결합되는 최상위 필드에 추가 필터를 제공하여 JCR 필터링을 활용할 수 있습니다. `AND` 연산자를 사용할 수 있습니다.

일반적인 사용 사례는 `_path` 최상위 조각의 필드를 만든 다음, 최상위 레벨 또는 중첩 조각에 있을 수 있는 추가 필드에 대해 필터링합니다.

이 경우 다른 필터 표현식이 `AND`. 따라서 `_path` 은 초기 결과 세트를 효과적으로 제한할 수 있습니다. 최상위 필드의 다른 모든 필터는 `AND`.

와 결합된 표현식 필터링 `OR` 중첩 조각이 포함된 경우에는 최적화할 수 없습니다. `OR` 표현식은 다음 경우에만 최적화할 수 있습니다 *아니요* 중첩된 조각이 관련되어 있습니다.

### 여러 줄 텍스트 필드를 필터링하지 마십시오 {#avoid-filtering-multiline-textfields}

여러 줄 텍스트 필드(html, markdown, 일반 텍스트, json)의 필드는 이러한 필드의 컨텐츠가 즉시 계산되어야 하므로 JCR 쿼리를 통해 필터링할 수 없습니다.

여전히 여러 줄 텍스트 필드를 필터링해야 하는 경우 필터 표현식을 추가하여 초기 결과 집합의 크기를 제한하는 것이 좋습니다 `AND`. 에서 필터링을 통해 범위 제한 `_path` 분야도 좋은 접근법이다.

### 가상 필드를 필터링하지 마십시오 {#avoid-filtering-virtual-fields}

가상 필드(대부분의 필드는 `_`)은 GraphQL 쿼리가 실행되는 동안 계산되며, JCR 기반 필터링의 범위를 벗어납니다.

한 가지 중요한 예외는 `_path` 초기 결과 세트의 크기를 줄이는 데 효과적으로 사용할 수 있는 필드 - 컨텐츠가 그에 따라 구조화된 경우(참조) [컨텐츠 구조 사용](#use-content-structure)).

### 필터링: 제외 {#filtering-exclusions}

필터 표현식을 JCR 수준에서 평가할 수 없는 상황이 몇 가지 있으며 따라서 최상의 성능을 얻으려면 피해야 합니다.

* 에서 표현식 필터링 `Float` 를 사용하는 값 `_sensitiveness` 필터 옵션 및 위치 `_sensitiveness` 다음 이외의 다른 항목으로 설정됩니다. `0.0` .

* 에서 표현식 필터링 `String` 값을 `_ignoreCase` 필터 옵션.

* 필터링 `null` 값.

* 배열의 필터 `_apply: ALL_OR_EMPTY`.

* 배열의 필터 `_apply: INSTANCES`, `_instances: 0`.

* 표현식을 사용하여 필터링 `CONTAINS_NOT` 연산자를 사용할 수 있습니다.

* 에서 표현식 필터링 `Calendar`, `Date` 또는 `Time` 를 사용하는 값 `NOT_AT` 연산자를 사용할 수 있습니다.
